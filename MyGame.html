<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Square Dodger ‚Äî MyGame</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #121826;
      --text: #e6eefc;
      --accent: #6ee7ff;
      --accent2: #a78bfa;
      --danger: #ff6b6b;
      --ok: #27c93f;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1000px 600px at 50% 0%, #10172a, var(--bg));
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }
    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 24px;
    }
    .card {
      width: min(92vw, 860px);
      background: linear-gradient(180deg, #0f1526aa, #0b0f1aee);
      border: 1px solid #23304b;
      border-radius: 18px;
      box-shadow: 0 10px 30px #0008, inset 0 1px 0 #ffffff10;
      padding: 18px;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 6px 14px;
      border-bottom: 1px solid #1e2941;
    }
    header h1 {
      font-size: clamp(18px, 2.8vw, 26px);
      margin: 0;
      letter-spacing: 0.4px;
    }
    header .badge {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #101a2f;
      border: 1px solid #243355;
      color: #b8d7ff;
    }
    .hud {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px 14px;
      align-items: center;
      padding: 10px 6px;
    }
    .hud span.label { opacity: 0.85; font-size: 13px; }
    .hud .pill {
      font-variant-numeric: tabular-nums;
      padding: 6px 10px;
      border-radius: 10px;
      background: #0e1730;
      border: 1px solid #203058;
      min-width: 70px;
      text-align: center;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      background:
         linear-gradient(180deg, #0b1226 0%, #0a1020 100%);
      border: 1px solid #1c2947;
      border-radius: 14px;
    }
    .footer {
      display: grid;
      gap: 6px;
      padding: 10px 6px 2px;
      color: #b7c6e6;
      font-size: 13px;
      opacity: 0.9;
    }
    kbd {
      background: #0f1a33;
      border: 1px solid #27375f;
      border-bottom-color: #1b294a;
      border-radius: 6px;
      padding: 2px 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      box-shadow: inset 0 -1px 0 #000;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 10px;
      background: #0e1830;
      border: 1px solid #26345a;
      color: #ddecff;
      cursor: pointer;
      user-select: none;
      text-decoration: none;
    }
    .btn:hover { filter: brightness(1.1); }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>üü¶ Square Dodger</h1>
        <span class="badge">HTML5 ‚Ä¢ Single File</span>
      </header>

      <div class="hud">
        <span class="label">Score</span>
        <div id="score" class="pill">0</div>

        <span class="label">Best</span>
        <div id="best" class="pill">0</div>

        <span class="label">Status</span>
        <div id="status" class="pill">Ready</div>
      </div>

      <canvas id="game" width="900" height="540" aria-label="Game canvas"></canvas>

      <div class="footer">
        <div class="row">
          <button id="startBtn" class="btn">‚ñ∂ Start</button>
          <button id="pauseBtn" class="btn">‚è∏ Pause</button>
          <button id="restartBtn" class="btn">‚Üª Restart</button>
          <a id="fullscreenBtn" class="btn" href="#">‚õ∂ Fullscreen</a>
        </div>
        <div>
          Controls: <kbd>‚Üê</kbd>/<kbd>‚Üí</kbd> or <kbd>A</kbd>/<kbd>D</kbd> to move,
          <kbd>P</kbd> to pause, <kbd>R</kbd> to restart.
        </div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // UI elements
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const statusEl = document.getElementById('status');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const restartBtn = document.getElementById('restartBtn');
      const fullscreenBtn = document.getElementById('fullscreenBtn');

      // Game state
      let running = false;
      let paused = false;
      let gameOver = false;
      let last = 0;
      let score = 0;
      let best = +localStorage.getItem('bestScore_v1') || 0;
      let spawnTimer = 0;

      bestEl.textContent = best;

      const world = {
        w: canvas.width,
        h: canvas.height,
        gravity: 0, // not used here but handy for tweaks
        speed: 200, // base obstacle fall speed (px/sec)
        speedIncrease: 12, // how much per 10s
      };

      const player = {
        x: world.w / 2 - 18,
        y: world.h - 60,
        w: 36,
        h: 36,
        speed: 360, // px/sec
        vx: 0,
        color1: '#6ee7ff',
        color2: '#a78bfa',
      };

      /** @type {Array<{x:number,y:number,w:number,h:number,vy:number,spin:number,hue:number}>} */
      let blocks = [];

      const keys = new Set();

      function rand(min, max) { return Math.random() * (max - min) + min; }

      function reset() {
        score = 0;
        world.speed = 200;
        spawnTimer = 0;
        blocks = [];
        player.x = world.w / 2 - player.w / 2;
        player.vx = 0;
        gameOver = false;
        paused = false;
        statusEl.textContent = 'Ready';
        drawTitle();
      }

      function start() {
        if (running && !gameOver) return;
        running = true;
        paused = false;
        gameOver = false;
        last = performance.now();
        statusEl.textContent = 'Playing';
        requestAnimationFrame(loop);
      }

      function pauseToggle() {
        if (!running || gameOver) return;
        paused = !paused;
        statusEl.textContent = paused ? 'Paused' : 'Playing';
        if (!paused) { last = performance.now(); requestAnimationFrame(loop); }
      }

      function gameOverNow() {
        gameOver = true;
        running = false;
        statusEl.textContent = 'Game Over';
        best = Math.max(best, Math.floor(score));
        localStorage.setItem('bestScore_v1', best);
        bestEl.textContent = best;
        drawGameOver();
      }

      function spawnBlock() {
        const size = rand(22, 46);
        blocks.push({
          x: rand(8, world.w - size - 8),
          y: -size,
          w: size,
          h: size,
          vy: world.speed + rand(-40, 80),
          spin: rand(-2, 2),
          hue: rand(200, 300) // bluish-purple range
        });
      }

      function update(dt) {
        // controls
        let dir = 0;
        if (keys.has('ArrowLeft') || keys.has('a')) dir -= 1;
        if (keys.has('ArrowRight') || keys.has('d')) dir += 1;
        player.vx = dir * player.speed;
        player.x += player.vx * dt;
        player.x = Math.max(8, Math.min(world.w - player.w - 8, player.x));

        // obstacles
        spawnTimer -= dt;
        const spawnEvery = Math.max(0.18, 0.9 - score * 0.01);
        if (spawnTimer <= 0) {
          spawnTimer = spawnEvery;
          spawnBlock();
        }

        for (const b of blocks) {
          b.y += b.vy * dt;
        }
        // remove off-screen
        blocks = blocks.filter(b => b.y < world.h + 60);

        // difficulty & score
        world.speed += world.speedIncrease * dt / 10;
        score += dt * 10;
        scoreEl.textContent = Math.floor(score);

        // collisions
        for (const b of blocks) {
          if (rectsOverlap(player, b)) {
            gameOverNow();
            break;
          }
        }
      }

      function rectsOverlap(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      function drawBackground() {
        // subtle grid/starfield
        ctx.save();
        const g = ctx.createLinearGradient(0, 0, 0, world.h);
        g.addColorStop(0, '#0c1326');
        g.addColorStop(1, '#0a0f20');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, world.w, world.h);

        // lines
        ctx.globalAlpha = 0.08;
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#6ee7ff';
        for (let x = 0; x <= world.w; x += 30) {
          ctx.beginPath();
          ctx.moveTo(x + 0.5, 0);
          ctx.lineTo(x + 0.5, world.h);
          ctx.stroke();
        }
        for (let y = 0; y <= world.h; y += 30) {
          ctx.beginPath();
          ctx.moveTo(0, y + 0.5);
          ctx.lineTo(world.w, y + 0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawPlayer() {
        const t = performance.now() / 1000;
        ctx.save();
        const grad = ctx.createLinearGradient(player.x, player.y, player.x + player.w, player.y + player.h);
        grad.addColorStop(0, player.color1);
        grad.addColorStop(1, player.color2);
        ctx.fillStyle = grad;
        ctx.shadowColor = '#6ee7ffaa';
        ctx.shadowBlur = 12 + 6 * Math.sin(t * 6);
        roundRect(ctx, player.x, player.y, player.w, player.h, 6, true);
        ctx.restore();
      }

      function drawBlocks() {
        for (const b of blocks) {
          ctx.save();
          ctx.translate(b.x + b.w / 2, b.y + b.h / 2);
          ctx.rotate(((performance.now()/1000) * b.spin) % (Math.PI*2));
          ctx.fillStyle = `hsl(${b.hue}, 90%, 60%)`;
          ctx.shadowColor = '#0008';
          ctx.shadowBlur = 8;
          roundRect(ctx, -b.w/2, -b.h/2, b.w, b.h, 5, true);
          ctx.restore();
        }
      }

      function drawTitle() {
        drawBackground();
        drawPlayer();
        ctx.save();
        ctx.fillStyle = '#cfe3ff';
        ctx.font = '600 32px Inter, system-ui, sans-serif';
        ctx.fillText('Press Start or R to begin', 24, 52);
        ctx.font = '14px Inter, system-ui, sans-serif';
        ctx.fillStyle = '#9fb5df';
        ctx.fillText('Avoid the falling blocks. Survive as long as you can!', 24, 76);
        ctx.restore();
      }

      function drawGameOver() {
        drawBackground();
        drawBlocks();
        drawPlayer();
        // overlay
        ctx.save();
        ctx.fillStyle = '#000c';
        ctx.fillRect(0, 0, world.w, world.h);
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd2d2';
        ctx.font = '700 40px Inter, system-ui, sans-serif';
        ctx.fillText('Game Over', world.w/2, world.h/2 - 10);
        ctx.fillStyle = '#e6eefc';
        ctx.font = '16px Inter, system-ui, sans-serif';
        ctx.fillText(`Score: ${Math.floor(score)}   ‚Ä¢   Best: ${best}`, world.w/2, world.h/2 + 24);
        ctx.fillStyle = '#b7c6e6';
        ctx.fillText('Press R to restart', world.w/2, world.h/2 + 48);
        ctx.restore();
      }

      function render() {
        drawBackground();
        drawBlocks();
        drawPlayer();
      }

      function loop(ts) {
        if (paused || gameOver) return;

        const dt = Math.min(0.033, (ts - last) / 1000); // cap delta for stability
        last = ts;

        update(dt);
        render();

        requestAnimationFrame(loop);
      }

      function roundRect(ctx, x, y, w, h, r, fill=true, stroke=false) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y,   x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x,   y+h, rr);
        ctx.arcTo(x,   y+h, x,   y,   rr);
        ctx.arcTo(x,   y,   x+w, y,   rr);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      // Resize canvas for crisp rendering on HiDPI
      function resizeCanvas() {
        const scale = Math.min(1.0, window.devicePixelRatio || 1);
        const baseW = 900, baseH = 540;
        const rect = canvas.getBoundingClientRect();
        const targetW = Math.round(rect.width * scale);
        const targetH = Math.round(baseH * (targetW / baseW));
        canvas.width = targetW;
        canvas.height = targetH;
        world.w = canvas.width;
        world.h = canvas.height;
        player.y = world.h - 60;
      }
      const ro = new ResizeObserver(resizeCanvas);
      ro.observe(canvas);
      resizeCanvas();

      // Input
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (['arrowleft','arrowright','a','d'].includes(k)) keys.add(e.key);
        if (k === 'p') { e.preventDefault(); pauseToggle(); }
        if (k === 'r') { e.preventDefault(); reset(); start(); }
      });
      window.addEventListener('keyup', (e) => {
        keys.delete(e.key);
      });

      startBtn.addEventListener('click', () => { if (gameOver) reset(); start(); });
      pauseBtn.addEventListener('click', () => pauseToggle());
      restartBtn.addEventListener('click', () => { reset(); start(); });
      fullscreenBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (canvas.requestFullscreen) canvas.requestFullscreen();
      });

      // boot
      reset();
    })();
  </script>
</body>
</html>
